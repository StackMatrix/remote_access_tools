# remote_access_tools project

## 程序功能
- 系统信息 ✅
- 键盘监控 ✅
- 屏幕监控 正在写...
- 文件获取 ❎
- 命令执行 ❎
- 并发扫描 ❎
- 浏览器窃密 ❎
- 

### 传输协议的抉择

#### 如何降低网络传输被发现的风险

降低网络传输被发现的风险，可以考虑以下措施

1. 使用加密协议进行通信。采用加密协议，例如 SSL/TLS 协议，可以对通信内容进行加密，从而使得网络流量看起来更加随机，并降低被发现的风险。
2. 使用隐藏协议进行通信。隐藏协议指的是采用特殊方式来传输数据，从而使得数据看起来不像是传输协议。例如，可以通过将数据编码为图像或者音频文件的形式，然后通过 HTTP 协议进行传输，从而使得数据看起来像是正常的图像或音频文件。
3. 使用混淆协议进行通信。混淆协议指的是采用特殊方法来混淆数据，使得数据看起来更加难以解析。例如，可以在数据中插入垃圾数据，从而使得数据看起来更加混淆。
4. 使用代理服务器进行通信。通过使用代理服务器，你可以让网络流量经过代理服务器，从而使得通信内容看起来更加复杂。例如，可以使用 TOR 网络作为代理服务

#### 如果使用自定义的通信协议传输数据会容易被发现么
如果使用自定义的通信协议传输数据，可能会容易被发现。安全软件通常会监控网络流量，并对网络中的恶意行为进行检测。如果安全软件发现了使用自定义协议进行通信，可能会触发安全警报。
使用自定义协议传输数据容易被发现的原因在于，安全软件通常会对常用的协议进行特征识别。如果使用自定义协议，那么这个协议可能不会被识别出来，因此可能会被安全软件误判为恶意协议。此外，使用自定义协议进行通信可能会更加容易被网络监控技术发现，因为这些技术通常只能监控常用的协议。
总之，如果你使用自定义的通信协议进行数据传输，应该注意防范被发现的风险。通常来说，使用常用的加密协议传输数据是更加安全的选择。

#### tcp 和 http 哪个协议更容易被发现

在一般情况下，TCP 协议和 HTTP 协议没有明显的区别，它们都可能会被安全软件和网络监控技术发现。这两种协议都是常用的协议，它们的报文格式和特征都很清晰，因此安全软件可以根据这些特征来识别这两种协议。
但是，在特定情况下，一种协议可能比另一种协议更容易被发现。例如，如果你使用 TCP 协议来进行恶意行为，比如攻击其他计算机，那么你的网络流量可能会被安全软件发现。此外，如果你使用 HTTP 协议来进行恶意行为，比如利用 HTTP 报文中的特定字段来传输恶意数据，那么你的网络流量可能会被安全软件发现。
总之，TCP 协议和 HTTP 协议都可能会被发现，但是在特定情况下，一种协议可能比另一种协议更容易被发现。

在某种程度上，使用自定义的通信协议也可能会被安全软件识别。这是因为安全软件通常会对网络流量进行深度分析，并根据分析结果来检测恶意行为。在这种情况下，安全软件可能会对自定义的协议进行分析，并根据协议的特征来判断是否存在恶意行为。不过，我们也要注意到，安全软件并不是百分之百准确的，它也有可能误报或误判。因此，使用自定义的通信协议仍然是一种有效的方法，可以降低被发现的风险。

总之，防范网络传输风险并不是一件容易的事情，需要从多个方面考虑问题并采取综合的措施。除了使用自定义的通信协议和代理服务器之外，还有很多其他的方法，例如使用混淆技术、隐藏网络信息、增强通信安全等等，都可以用来降低被发现的风险。

#### 这些协议容易被发现的地方在哪里

TCP 协议在哪些方面容易被发现取决于你使用 TCP 协议进行通信的目的和方式。通常来说，TCP 协议在以下几个方面可能容易被发现：

1. 特征识别。安全软件通常会对常用的协议进行特征识别，并根据这些特征来检测恶意行为。这意味着，无论你是使用 HTTP 协议还是使用 TCP 协议，安全软件都可能会根据这些协议的特征来检测你的网络流量。
2. 端口扫描。安全软件通常会对网络中的端口进行扫描，并根据端口的状态来判断是否存在恶意行为。这意味着，无论你是使用 HTTP 协议还是使用 TCP 协议，安全软件都可能会对你所使用的端口进行扫描，并根据扫描结果来检测你的网络流量。
3. 深度分析。安全软件通常会对网络流量进行深度分析，并根据分析结果来检测恶意行为。这意味着，无论你是使用 HTTP 协议还是使用 TCP 协议，安全软件都可能会对你的网络流量进行深度分析，并根据分析结果来检测你的网络流量。

总之，TCP 和 http 协议在以上几个方面可能容易被发现。如果你希望在使用这些协议进行通信时避免被发现，应该注意防范这些方面的风险。

#### 防范被发现的风险具体需要怎么做

要防范使用协议在以上几个方面的被发现风险，你可以采用以下技术：

1. 加密。通过使用加密技术，可以使你的网络流量不易被安全软件识别。常用的加密技术包括 HTTPS 和 VPN。
2. 隐藏。通过隐藏你的网络流量，可以使你的网络流量不易被安全软件发现。常用的隐藏技术包括端口隐藏和数据隐藏。
3. 混淆。通过混淆你的网络流量，可以使你的网络流量不易被安全软件识别。常用的混淆技术包括报文混淆和协议

通过以上技术，你可以防范 TCP 协议在特征识别、端口扫描和深度分析方面的风险。不过，要注意，这些技术都有一定的局限性，并不能完全避免你的网络流量被发现。因此，如果你希望使用 TCP 协议进行安全通信，应该结合多种技术来提高通信安全性。

“多种技术” 指的是在使用 TCP 协议进行通信时，应该结合多种技术来提高通信安全性。这些技术包括加密技术、隐藏技术和混淆技术。例如，你可以使用 HTTPS 协议来加密网络流量，使用端口隐藏技术来避免网络流量被发现，并使用报文混淆技术来防止网络流量被识别。通过结合这些技术，你可以有效提高通信安全性。

一般来说，HTTP 协议在传输过程中更加常用。所以可以采用 http 协议。

#### 我应该是用自定义协议还是 http 协议呢？

实际上，使用自定义的通信协议还是 HTTP 协议，取决于你的具体需求和使用场景。

如果你希望实现一个更加灵活和安全的通信协议，那么使用自定义的通信协议可能是一个不错的选择。自定义的通信协议可以更加灵活，可以根据你的具体需求来定制，并且可以有效地掩盖协议的特征，降低被发现的风险。

但如果你希望使用一种标准化的协议，并且需要与其他系统进行互通，那么使用 HTTP 协议可能会更加方便。HTTP 协议是目前最常用的应用层协议之一，它已经成为互联网的基础协议，广泛应用于各种系统之间的通信。使用 HTTP 协议，你可以轻松地与其他系统进行互通，并且可以依靠海量的资源来支持和提升你的通信应用。

总之，是使用自定义的通信协议还是 HTTP 协议，取决于你的具体需求和使用场景。你可以根据实际情况来进行选择，并采取相应的措施来保护你的软件。

#### 选择 http 作为传输协议

注意隐蔽性和灵活性。在使用 HTTP 协议时，建议你注意不要使用显然的端口和 URL，例如 80 端口和 /api 这样的端口和 URL。另外，建议你在实现代码时，具备足够的灵活性，例如可以设置不同的超时时间，或者动态修改 HTTP 请求头等信息。这些措施都可以有效地降低被发现的风险，并且可以提高通信的灵活性和可靠性。



## 1. 压缩库

### 1.0 [zstd 库]("https://docs.rs/crate/zstd/0.12.1+zstd.1.5.2")
zstd 是一个开源的压缩库，用于实现高压缩率的数据压缩和解压缩,它是一个高性能的压缩库，
可以用于压缩各种类型的数据，包括文本、图像、视频等。该库实现了多种压缩算法，可以根据需要选择合适的算法来进行压缩。
它还提供了一些高级特性，如压缩字典、多线程压缩、数据流压缩等。
zstd 库主要用于提高网络传输效率、存储空间使用率、数据库备份速度等方面。
它一种流行的数据压缩算法，它可以用来快速压缩数据。它提供了许多不同的压缩级别，可以根据应用需求来选择合适的压缩级别。
它可以比标准的压缩工具（如 gzip 和 bzip2）提供更高的压缩率，并且运行速度也更快。
还可以在多种编程语言中使用，包括 C、C++、Java、Python 等。可以作为一个独立的压缩工具，也可以作为一个库，集成到其他程序中。
#### 1.0.0 CCtx - 压缩上下文

CCtx 是 zstd 库的一个类型，它代表了一个压缩上下文。

- 压缩上下文的创建
通过创建一个压缩上下文，就可以调用 zstd 库提供的压缩和解压函数，实现数据的压缩和解压。
```rust
    let mut ctx = CCtx::create();
```

- 压缩的等级
`zstd` 库提供了多种压缩等级。例如：
```rust
    zstd::constants::ZSTD_defaultCompression：默认的压缩等级，对应的整数值为 -1。
    zstd::constants::ZSTD_maxCompression：最高的压缩等级，对应的整数值为 22。
    zstd::constants::ZSTD_fast：快速压缩等级，对应的整数值为 1。
    zstd::constants::ZSTD_btopt：最优压缩等级，对应的整数值为 11。
```

#### 1.0.1 [miniz-oxide 库]("")

它是一个小巧、快速的压缩库，可以用来实现各种常见的压缩算法，包括 DEFLATE，zlib 和 gzip。

### 1.1 [lz4 库]("")

是一个快速的压缩算法，可以提供比 miniz-oxide 更快的压缩速度。
它有一个 Rust 实现，可以用来在 Rust 程序中实现高性能压缩。
lz4 是一种无损数据压缩算法，它可以用来对数据进行压缩，以便节省存储空间或者减少网络传输数据量。
lz4 算法是一种基于字典的压缩算法，它可以快速压缩数据并提供较高的压缩比。它是一种流行的压缩算法，广泛用于各种应用，包括文件系统、数据库和网络协议等。
lz4 算法的优点是压缩速度快，压缩比高，而且可以实现多线程压缩。它的缺点是压缩后的数据不能解压缩，只能用于无损压缩场景。
总之，lz4 是一种高性能的无损数据压缩算法，适用于需要快速压缩的应用场景。



## 2. 线程库

### 2.0 [rayon 库]("")

Rayon 是一个用来简化并行编程的 Rust 库。它提供了一些实用的工具和抽象，使得开发人员能够轻松地实现并行算法。
例如，Rayon 提供了一些并行迭代器，可以在多个线程上并行地进行数据处理。例如，par_iter() 方法可以创建一个并行迭代器，用来遍历数组中的元素。
例如：

```rust
    // 创建一个包含 10 个元素的数组
    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    // 在数组上调用 par_iter() 方法，创建一个并行迭代器
    let par_numbers = numbers.par_iter();

    // 遍历并行迭代器中的元素
    for number in par_numbers {
        println!("{}", number);
    }
```



## 3. 加密库

如果想使用加密技术来保护数据的安全性，可以使用 Rust 中的一些加密库，例如 ring、openssl 等库。

### 3.0 [ring 库]("https://docs.rs/ring/0.16.20/ring/")

使用 Rust 和 BoringSSL 的加密原语的安全、快速、小型加密。

使用 ring 库来加密数据，可以使用如下代码：

```rust
// 引入 ring 库
use ring::{aead, digest, hmac};

// 创建密钥
let key = [0u8; 32];

// 对数据进行加密
let data = b"原始数据";
let nonce = aead::Non
```



我们可以通过在请求消息中设置消息头，来实现隐匿信息。例如，我们可以在请求消息的消息头中设置 User-Agent 字段，用来指定客户端的类型，例如：

```
Copy code
// 设置 User-Agent 字段
let response = reqwest::get("https://www.example.com/")
    .header(reqwest::header::USER_AGENT, "Rust 语言")
    .await
    .expect("GET 请求失败");
```

我们也可以在请求消息的消息头中设置其它字段，例如设置 Accept 字段，用来指定客户端可以处理的内容类型，例如：

```
Copy code
// 设置 Accept 字段
let response = reqwest::get("https://www.example.com/")
    .header(reqwest::header::ACCEPT, "application/json")
    .await
    .expect("GET 请求失败");
```

当服务器收到请求消息时，会根据消息头的内容来决定如何处理请求，从而可以实现隐匿信息的目的。



我们还可以使用代理服务器来隐藏客户端的信息。例如，我们可以使用 reqwest 库，并设置代理服务器的地址，来实现通过代理服务器发送请求的目的，例如：

```
Copy code
// 设置代理服务器地址
let response = reqwest::get("https://www.example.com/")
    .proxy(reqwest::Proxy::http("http://proxy.example.com:8080/")?)
    .await
    .expect("GET 请求失败");
```

通过代理服务器发送请求时，代理服务器会接收客户端的请求，并将请求转发给目标服务器，然后将目标服务器的响应转发给客户端。由于客户端的请求是通过代理服务器发送的，因此目标服务器看到的请求是来自代理服务器的，而不是来自客户端的，从而实现隐匿信息的目的。

总之，我们可以通过 HTTPS 协议、加密技术、消息头、代理服务器等方式来实现在 Rust 中隐匿发送的信息。





## 4. 线程间传递数据

我需要在多个线程间传递不同结构体及其数据，并将这些数据保存。

app_state.rs

```rust
#[derive(Debug)]
pub struct MainTestStruct {
    pub a: Vec<String>,
    pub b: Vec<String>,
}

#[derive(Debug)]
pub enum State {
    AState(A),
    BState(B),
}

#[derive(Debug)]
pub struct A {
    pub info: String,
}

#[derive(Debug)]
pub struct B {
    pub info: String,
}
```

app_logic.rs

```rust
use super::app_state::{MainStruct, MainTestStruct, A, B, State};
use tokio::sync::{oneshot, mpsc};

pub async fn run() {
    let mut main_test_struct = MainTestStruct::new();
    let (sender1, mut receiver) = mpsc::channel(32);
    let sender2 = sender1.clone();
    let sender3 = sender1.clone();
    
    let recvicer = tokio::spawn(async move {
        while let Some(data) = receiver.recv().await {
            match data {
                State::AState(value) => {
                    main_test_struct.a.push(value.info.to_string());
                },
                State::BState(value) => {
                    main_test_struct.b.push(value.info.to_string());
                }
            }
            
            dbg!("now data is:{}", &main_test_struct);
        }
    });
    
    let send1 = tokio::spawn(async move {
        // let (tx, rx) = oneshot::channel();
        let state2 = State::BState(B { info: "bbb".to_string() });
        sender2.send(state2).await.unwrap();

        let state3 = State::AState(A { info: "aaaa".to_string() });
        sender3.send(state3).await.unwrap();
    });
    
    system_info_logic::get_info(&mut main_struct, sender1).await;
    
    recvicer.await.unwrap();
    send1.await.unwrap();
}
```

system_info_logic.rs

```rust
pub async fn get_info(main_struct: &mut Arc<Mutex<MainStruct>>, sender1: Sender<State>) {
    tokio::spawn(async move {
        // let (tx, rx) = oneshot::channel();
        let state = State::AState(A { info: "a".to_string() });
        
        sender1.send(state).await.unwrap();
    });
}
```







